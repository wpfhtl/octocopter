#ifndef OGREWIDGET_H
#define OGREWIDGET_H

#include <QtGui>
#include <QApplication>
#include <QWidget>
#include <QGLWidget>
#include <QDebug>
#include <QColor>
#include <QTimer>
#include <QMutex>
#include <QMutexLocker>
#include <Ogre.h>
#include <QX11Info>
#include <QKeyEvent>

#include "simulator.h"
#include "laserscanner.h"
#include <waypoint.h>

#include <Terrain/OgreTerrain.h>
#include <Terrain/OgreTerrainGroup.h>
#include "Terrain/OgreTerrainQuadTreeNode.h"
#include "Terrain/OgreTerrainMaterialGeneratorA.h"
#include <OgrePageManager.h>
#include <RTShaderSystem/OgreShaderGenerator.h>

#define TERRAIN_PAGE_MIN_X 0
#define TERRAIN_PAGE_MIN_Y 0
#define TERRAIN_PAGE_MAX_X 0
#define TERRAIN_PAGE_MAX_Y 0
#define TERRAIN_WORLD_SIZE 1000.0f
#define TERRAIN_SIZE 513

class Simulator;

/** This class simply demonstrates basic usage of the CRTShader system.
It subclasses the material manager listener class and when a target scheme callback
is invoked with the shader generator scheme it tries to create an equvialent shader
based technique based on the default technique of the given material.
*/
class ShaderGeneratorTechniqueResolverListener : public Ogre::MaterialManager::Listener
{
public:
    ShaderGeneratorTechniqueResolverListener(Ogre::RTShader::ShaderGenerator* pShaderGenerator)
    {
        mShaderGenerator = pShaderGenerator;
    }

    virtual Ogre::Technique* handleSchemeNotFound(
            unsigned short schemeIndex,
            const Ogre::String& schemeName,
            Ogre::Material* originalMaterial,
            unsigned short lodIndex,
            const Ogre::Renderable* rend)
    {
        // Case this is the default shader generator scheme.
        if (schemeName == Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME)
        {
            MaterialRegisterIterator itFind = mRegisteredMaterials.find(originalMaterial);
            bool techniqueCreated = false;

            // This material was not registered before.
            if (itFind == mRegisteredMaterials.end())
            {
                techniqueCreated = mShaderGenerator->createShaderBasedTechnique(
                        originalMaterial->getName(),
                        Ogre::MaterialManager::DEFAULT_SCHEME_NAME,
                        schemeName);
            }
            mRegisteredMaterials[originalMaterial] = techniqueCreated;
        }

        return NULL;
    }

protected:
    typedef std::map<Ogre::Material*, bool> MaterialRegisterMap;
    typedef MaterialRegisterMap::iterator MaterialRegisterIterator;


protected:
    // Registered material map.
    MaterialRegisterMap mRegisteredMaterials;

    // The shader generator instance.
    Ogre::RTShader::ShaderGenerator* mShaderGenerator;
};



class OgreWidget : public QWidget
{
    Q_OBJECT

public:
    struct MeshInformation
    {
        bool valid;
        size_t vertex_count;
        size_t index_count;
        Ogre::Vector3 *vertices;
        Ogre::uint32 *indices;
        Ogre::SceneNode* sceneNode;
        Ogre::AxisAlignedBox aabb; // this is generated by using the meshes aabb and transforming it with the scenenodes transform.

        MeshInformation() { valid = false; }
    };

    enum TranslationMode {TRANSLATION_RELATIVE, TRANSLATION_ABSOLUTE};

    OgreWidget(Simulator *simulator);
    ~OgreWidget();

    // will create the vehicle node at the followin position, set the @entity pointer, set the animationstate for later (when rendering) and return the scenenode
    Ogre::SceneNode* createVehicleNode(const Ogre::String name, Ogre::Entity** entity, const Ogre::Vector3 position, const Ogre::Quaternion orientation);

    // Creates a scannerNode and attaches a mesh to it.
    Ogre::SceneNode* createScanner(
            const QString name,
            const Ogre::Vector3 &relativePosition = Ogre::Vector3::ZERO,
            const Ogre::Quaternion &relativeRotation = Ogre::Quaternion::IDENTITY);

    void destroyScanner(const QString name);

    // Creates a camera for rendering to texture
    void createRttCamera(Ogre::Camera** camera, Ogre::RenderTarget** renderTarget, Ogre::SceneNode** sceneNode, const QString name, const QSize size);
    void destroyRttCamera(const QString name/*, Ogre::RenderTarget* renderTarget, Ogre::Camera* camera*/);

    Ogre::SceneManager* sceneManager();

    // Public access needed for the laserscanners rayIntersects()
    Ogre::TerrainGroup* mTerrainGroup;

    void createManualObject(
            const QString &name,
            Ogre::ManualObject** manualObject,
            Ogre::SceneNode** sceneNode,
            Ogre::MaterialPtr& material);

    void destroyManualObject(Ogre::ManualObject* manualObject, Ogre::SceneNode* sceneNode);

    QMap<Ogre::Entity*, MeshInformation*> mEntities;

public slots:
    void slotVisualizeTrajectory(const QVector3D& start, const QList<WayPoint>& waypoints);

signals:
    void setupFinished();
    void cameraPositionChanged(const Ogre::Vector3 &pos);
    void currentRenderStatistics(QSize windowSize, int triangles, float fps);

protected:
    void keyPressEvent(QKeyEvent *e);

    void moveEvent(QMoveEvent *e);
    void mouseMoveEvent(QMouseEvent *e);
    void mousePressEvent(QMouseEvent *e);
    void mouseReleaseEvent(QMouseEvent *e);
    void wheelEvent(QWheelEvent *e);
    void paintEvent(QPaintEvent* event);
    void initializeOgre();
    void resizeEvent(QResizeEvent* event);

private:
    // Terrain:
    Ogre::TerrainGlobalOptions* mTerrainGlobals;
    Ogre::RTShader::ShaderGenerator* mShaderGenerator;

    // Shader generator material manager listener.
    ShaderGeneratorTechniqueResolverListener* mMaterialMgrListener;

    void configureTerrainDefaults(Ogre::Light* l);
    void defineTerrain(long x, long y, bool flat = false);
    void getTerrainImage(bool flipX, bool flipY, Ogre::Image& img);
    void initBlendMaps(Ogre::Terrain* terrain);
    bool initializeRTShaderSystem(Ogre::SceneManager* sceneMgr);

    Ogre::Vector3 mTerrainPos;
    bool mTerrainsImported;

    void loadResources();
    void setupTerrain();

    Simulator* mSimulator;

    static const Ogre::Real turboModifier;
    static const QPoint invalidMousePoint;

    mutable QMutex mMutex;

    Ogre::Root          *mOgreRoot;
    Ogre::SceneManager  *mSceneManager;
    Ogre::RenderWindow  *mOgreRenderWindow;
    Ogre::Viewport      *mOgreViewport;
    Ogre::Camera        *mCamera;

    quint32 mFrameCount;// currently only used to emit statistics not every frame
    QPoint oldPosL, oldPosR;
    bool btnL, btnR;

    QList<Ogre::SceneNode*> mScannerNodes;

    Ogre::SceneNode *selectedNode;
    Ogre::SceneNode *mCameraNode;
    Ogre::Entity *mVehicleEntity;
    Ogre::SceneNode *mVehicleNode;

    Ogre::ManualObject* mTrajectoryLine;

    void addMeshInformation(Ogre::Entity* entity, Ogre::SceneNode* node);

    // for the raycasting against entities (not ground)
    void getMeshInformation(const Ogre::MeshPtr mesh,
                                    size_t &vertex_count,
                                    Ogre::Vector3* &vertices,
                                    size_t &index_count,
                                    Ogre::uint32* &indices,
                                    const Ogre::Vector3 &position,
                                    const Ogre::Quaternion &orient,
                                    const Ogre::Vector3 &scale);

};

#endif
